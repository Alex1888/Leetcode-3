mutable 易变的
题意：
303 follow up,在一个可改变数值大小的数组中求出指定坐标内的和。
思路：
T(n) = logn;
1.利用树状数组的性质奇数位置的数字和原数组对应位置的相同，偶数位置是原数组若干位置之和
便于快速计算数组内的和和更新数组
2.首先需要用一个num数组记录原数组中的值，bit数组表示创建的树状数组
3.为了便于操作,num和bit的第0为都置为空，因此创建的时候比最初的数组大小大一位，后面从1开始操作，因此后面的方法都要在原来的基础上+1
4.在构造器中利用undate方法初始化num数组，后面值的更新也利用这个方法
5.在update方法中首先计算需要更新的差值，即新的值-当前值。遍历bit数组的当前位，加上需要相加的值，当前位跳转到需要相加的下一位。
下一位即通过(j&-j)方法确认的位置。同时在num数组中更新新的值，便于后面的更新。
6.注意树状数组的求和需要从尾部开始，因为尾部相加之后就不需要重复相加前面重复的值了，也因此提高了效率。
相加的方式是用指定范围，在树状数组的中查找，用右边界+1减去左边界可得。
7.求和方法即从尾部开始循环bit数组，用一个变量记录和的值。
class NumArray {
private:
    vector<int>num;
    vector<int>bit;
public:
    NumArray(vector<int> nums) {
        num.resize(nums.size()+1);
        bit.resize(nums.size()+1);
        for(int i = 0; i < nums.size();++i){
            update(i, nums[i]);
        }
    }
    
    void update(int i, int val) {
        int diff = val - num[i+1];
        for(int j = i+1; j < num.size(); j +=(j&-j)){
            bit[j] += diff;
        }
        num[i+1] = val;
    }
    
    int sumRange(int i, int j) {
        return getSum(j+1) - getSum(i);
    }
    
    int getSum(int i){
        int ans = 0;
        for(int j = i; j > 0; j -= (j&-j)){
            ans += bit[j];
        }
        return ans;
    }
};

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * obj.update(i,val);
 * int param_2 = obj.sumRange(i,j);
 */
知识补充：
1.BIT：binary indexed tree 树状数组
树状数组实际上是对原数组的指定位置进行求和，形成了一个新数组。
A表示原数组，C表示新数组。
C1 = A1
C2 = A1 + A2
C3 = A3
C4 = A1 + A2 + A3 + A4
C5 = A5
C6 = A5 + A6
C7 = A7
C8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8
...
C16 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8 + A9 + A10 + A11 + A12 + A13 + A14 + A15 + A16
那么是如何确定某个位置到底是有几个数组成是根据坐标的最低位Low Bit来决定的，所谓的最低位，就是二进制数的最右边的一个1开始，加上后面的0(如果有的话)组成的数字，例如1到8的最低位如下面所示：
坐标           二进制          最低位
1               0001          1
2               0010          2
3               0011          1
4               0100          4
5               0101          1
6               0110          2
7               0111          1
8               1000          8
求最低位用补码特性： x&(-x)
x为原数的二进制表示，-x表示-x的补码，即原数取反，最后+1.
&在都是1的时候为1，其余情况为0.
--------------------------------------------------
BIT从0-n求和，复杂度logn，但是要从最高位开始计算
int Sum = 0; // 第一步定义和为0
while(n > 0){
    Sum += C[n]; // 第二步 在 n > 0的情况 加上第n个节点
    n -= lowbit(n); //第三步 让n跳到上一个需要加的位置
}
举例：比如n=7,7的位置上只有一个数，最低位为1，那么会跳到6
     6的位置上有2个数，最低位为2，接着跳到4
     4的位置上有4个数，最低位为4，跳到0，结束循环
--------------------------------------------------
BIT更新数据，复杂度logn，从头部开始计算
//如果更新第i个数据，让其 +1
while(i <= n){ //一共n个数据，第0号节点无数据，所以下标到n
    C[i] += 1; // 更新数据
    i += lowbit(i); // 下一个要更新的位置
}

2.补码、反码和原码
(1)机器数：
一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.
比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。
那么，这里的 00000011 和 10000011 就是机器数
(2)真值：
因为第一位是符号位，所以机器数的形式值就不等于真正的数值。
例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。
所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。
例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1
(3)原码：
原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值.
比如如果是8位二进制:
[+1]原 = 0000 0001
[-1]原 = 1000 0001
第一位是符号位. 
因为第一位是符号位, 所以8位二进制数的取值范围就是:[1111 1111 , 0111 1111]，即[-127 , 127]
(4)反码：
反码的表示方法是:
正数的反码是其本身
负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.
[+1] = [00000001]原 = [00000001]反
[-1] = [10000001]原 = [11111110]反
(5)补码
正数的补码就是其本身
负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)
[+1] = [00000001]原 = [00000001]反 = [00000001]补
[-1] = [10000001]原 = [11111110]反 = [11111111]补
(6)用途
[+1] = [00000001]原 = [00000001]反 = [00000001]补
[-1] = [10000001]原 = [11111110]反 = [11111111]补
为了用另外的方式记录下数字的正负，不需要机器再单独辨别符号位，简化运算
3.C++ STL中reserve()和resize()的区别
reserve()是为数组来分配内存，而数组中目前的大小是数组的size
resize()是用来改变vector的大小，即vector中元素的数量，我们可以说，resize方法改变了容器的大小，且创建了容器中的对象；
如果resize中所指定的n小于vector中当前的元素数量，则会删除vector中多于n的元素，使vector得大小变为n；
如果所指定的n大于vector中当前的元素数量，则会在vector当前的尾部插入适量的元素，使得vector的大小变为n。
在这里，如果为resize方法指定了第二个参数，则会把后插入的元素值初始化为该指定值，如果没有为resize指定第二个参数，则会把新插入的元素初始化为默认的初始值0；
如果resize所指定的n不仅大于vector中当前的元素数量，还大于vector当前的capacity容量值时，则会自动为vector重新分配存储空间；
