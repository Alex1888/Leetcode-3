题意：
091 follow up,数字型的字符串有可能有*，*可以代表任何数字，问一共有多少种输出的情况。
思路：
1.这类题一类一类分情况讨论即可：
设置一个DP数组，dp[i]用来表示到第i位一共可能有多少种情况。注意因为要初始化第0位，因此需要把数组的长度比字符串的长度大1。
2.初始化DP数组，dp[0] == 1.
如果字符串第一位是0，那么直接返回0；
如果是*，那么dp[1] = 9;
其他情况初始值为1；
3.开始递推关系：
(1)如果遍历到了0，判断其前一位的值。
如果前一位是1或者2，dp[i] += dp[i-2];
如果前一位是*，那么在1，2的时候满足题意，那么dp[i] = 2*dp[i-2];
如果是其他数字的情况，那么返回0.
(2)如果遍历到了*
如果其前一位是1，该位可以有9种情况，dp[i] = 9*dp[i-2];
如果其前一位是2，那么可以有6种情况，dp[i] = 6*dp[i-2];
如果其前一位是*，那么是上两种情况加和，dp[i] = 15*dp[i-2];
(3)如果遍历到其他数字
首先可以一位一位相加，dp[i] += dp[i-1];
判断其前两位是否满足在[10,26]之间，dp[i] += dp[i-2];
如果其前一位是*，那么如果当前位小于等于6，dp[i] += *2dp[i-2]
如果其前一位是*，那么如果当前位大于6，dp[i] += dp[i-2];
4.因为最后的数字会很大，首先DP数组中声明的时候要用long long,最后还要对结果取余，10的9次方+7等于1e9+7
注意：
1.因为dp数组的坐标永远比字符串大1，不论遍历过程中还是求结尾位置时都需要注意
2.判断字符串中某个位数的字符时要用''括起来
class Solution {
public:
    int numDecodings(string s) {
        vector<long>dp(s.size()+1,0);
        int M = 1e9 +7;
        dp[0] = 1;
        if(s[0] == '0') return 0;
        else if(s[0] == '*') dp[1] = 9;
        else dp[1] = 1;
        for(int i = 2 ; i < dp.size();++i){
            if(s[i-1] == '0'){
                if(s[i-2] == '1' || s[i-2] == '2') dp[i] += dp[i-2];
                else if(s[i-2] == '*') dp[i] += 2*dp[i-2];
                else return 0;
            }else if(s[i-1] == '*'){
                dp[i] += 9*dp[i-1];
                if(s[i-2] == '1') dp[i] += 9*dp[i-2];
                else if(s[i-2] == '2') dp[i] += 6*dp[i-2];
                else if(s[i-2] == '*') dp[i] += 15*dp[i-2];
            }else{
                dp[i] += dp[i-1];
                if(s[i-2] == '1' || (s[i-2] == '2' && s[i-1] <= '6')) dp[i] += dp[i-2];
                if(s[i-2] == '*' && s[i-1] <= '6') dp[i] += 2*dp[i-2];
                if(s[i-2] == '*' && s[i-1] > '6') dp[i] += dp[i-2];
            }
            dp[i] %= M;
        }
        return dp.back();
    }
};