知识补充：
1.UNIX
*是一种操作系统，所有的操作系统为它们所运行的程序提供服务，比如包括：执行新程序、打开文件、读文件、分配内存等等
*UNIX是闭源的，LINUX是开源的。LINUX是UNIX的开源实现，也可以认为LINUX是UNIX的现代版
*UNIX体系结构
把控制计算机【内核】，提供程序运行环境的通常称为内核，kernel,位于环境的核心
内核的接口称为【系统调用】，system call, 包围在内核周围
【公用函数】可构建在系统调用的接口之上，【shell】是一个特殊的应用程序，为运行其他应用程序提供了一个接口
应用程序既可以使用公用函数库，也可以直接系统调用，或者通过shell命令
2.shell
用户登录操作系统之后，系统通常先显示一些系统信息，之后用户就可以向shell程序键入命令。
shell是一个命令行解释器，它读取用户输入，之后执行命令。
shell的用户输入通常来自于终端（交互式shell),有时则来自于文件（shell脚本）
常见的shell:
Bourne shell: /bin/sh; bash的副本
Bourne-again shell: /bin/bash
3.bash
在bash执行环境中，我们讲到了通配符的用法。
这里要注意的是，正则表达式与shell脚本内置的通配符不同，shell通配符主要用于对文件名展开，因此是很简单的一种正则；
而这里要讲解的正则表达式在grep,sed,awk等工具中经常用到，可以做非常强大的匹配操作。
4.正则表达式
脱字符 ^ 匹配一行的开头,但依赖于上下文环境,可能在正则表达式中表示否定一个字符集的意思
美元符 $ 在正则表达式中匹配行尾。"^$" 匹配空行.
方括号 [] 在正则表达式中表示匹配括号中的一个字符.
        "[xyz]" 匹配字符x, y, 或z.
        "[c-n]" 匹配从字符c到n之间的任意一个字符.
        "[B-Pk-y]" 匹配从B到P 或从k到y的任意一个字符.
        "[a-z0-9]" 匹配任意小写字母或数字.
        "[^b-d]" 匹配除了从b到d范围内所有的字符. 这是正则表达式中反转意思或取否的一 个例子.(就好像在别的情形中!字符所扮演的角色).
反斜杠字符 \ 转义(escapes) 一个特殊的字符,使这个字符表示原来字面上的意思.
            "\$"表示了原来的字面意思"$",而不是在正则表达式中表达的匹配行尾的意思.同样,"\\"也被解释成了字面上的意思"\".
圆括号 () 括起一组正则表达式. 
竖线   | "或"正则操作符用于匹配一组可选的字符.
5.awk
awk是一个强大的文本分析工具，在对文本文件的处理以及生成报表，awk是无可替代的。
awk认为文本文件都是结构化的，它将每一个输入行定义为一个记录，行中的每个字符串定义为一个域(段)，域和域之间使用分割符分割。
6.sed
sed是一款流编辑工具，用来对文本进行过滤与替换工作.
sed通过输入读取文件内容，但一次仅读取一行内容进行某些指令处理后输出，sed更适合于处理大数据文件。
7.grep
grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。
如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。
搜索的结果被送到标准输出，不影响原文件内容。
grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。
我们利用这些返回值就可进行一些自动化的文本处理工作。


题目：
有一个file.txt文件，有以下这几种电话的表示方式：
987-123-4567
123 456 7890
(123) 456-7890
需要筛选出下面这种格式的：
987-123-4567
(123) 456-7890
思路：
1.通过观察发现，合格的格式只在前面有区别987-（XXX-）或者(123) （XXX） 格式的
2.因此判断前几位即可
*********************************************
awk写法：
awk '/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$/' file.txt
逐字解释：
最外侧的'/.../'表示中间是要匹配的正则表达式
()括起一组正则表达式，中间的|表示或的关系
[0-9]{3}表示从9个数字中选3个
-匹配原字符中的-
\为转义的含义，需要匹配原字符中的\(\)
后面以此类推
注意正则表达式结束后需要【空格】再添加需要查找的文件
*********************************************
sed写法：
sed -n -r '/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$/p' file.txt
-n表示关闭默认输出，默认将自动打印所有行，这样就不会打印出不符合要求的数字串了。
-r表示支持扩展正则+ ? () {} |。
最后的p，在用sed时，p和-n合用，表示打印某一行，这样才能把符合要求的行打印出来
*********************************************
grep写法：
grep -P '^(\d{3}-|\(\d{3}\) )\d{3}-\d{4}$' file.txt
用\d{3}替换[0-9]{3}
在mac OS系统中-P已经默认添加了，所以不需要写-P
-P, --perl-regexp	Interpret PATTERN as a Perl regular expression. This functionality is still experimental, and may produce warning messages.
Perl -regexp将模式解释为Perl正则表达式。这个功能还处于试验阶段，可能会产生警告信息。