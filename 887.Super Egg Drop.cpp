题意：掉鸡蛋问题，问通过给定个鸡蛋最小多少次能找到使鸡蛋破碎的楼层
方法一：依据题意的暴力DP
TLE，T(n) = O(K * N^2);
思路：
1.因为本题中后面所有扔鸡蛋的情况都需要取决于之前的鸡蛋的破碎情况，所以利用DP解题是合适的
2.建立一个DP数组，dp[i][j]表示在第i层第j个鸡蛋的时候最多需要多少次可以找出
最后返回dp[N][K]
3.首先创建初始值，如果没有鸡蛋，那么就是0；如果有一个鸡蛋，那么最多的次数就是楼层数
4.开始从第二个鸡蛋和第一个楼层开始遍历，改位置的初始值，也就是最多的情况就是与楼层数相等
5.动态转移方程：
在某一层扔鸡蛋，如果鸡蛋坏了，那么需要用少一个鸡蛋来找低一层的结果
如果鸡蛋没坏，那么需要用同样数量的鸡蛋来找高一层到顶层之间的结果
因为需要找到的是最坏的结果，那么dp[i][j]= max(dp[i-1][k-1], dp[n-i][k]) + 1
6.每当遍历到每一层，就把当前层设置为最高层，那么需要一个K去从第一层遍历到最高层来不断更新dp[i][j]
最后取所有结果中较小的一个
class Solution {
public:
    int superEggDrop(int K, int N) {
        vector<vector<int>>dp(N+1,vector<int>(K+1,0));
        for(int i= 0; i <= N; ++i){
            dp[i][0] = 0;
            dp[i][1] = i;
        }
        for(int j = 2; j <= K; ++j){
            for(int i = 1; i <= N; ++i){
                dp[i][j] = i;
                for(int s = 1; s < i; ++s)
                dp[i][j] = min(dp[i][j],max(dp[s-1][j-1],dp[i-s][j])+1);
            }
        }
        return dp[N][K];
    }
};

方法2:dp
T(n) = O(K * N)
思路：
1.因为在上面的方法中需要对鸡蛋和层数都需要进行遍历，那么换一种dp的思路
2.用dp[i][j]来表示用i个鸡蛋在第j步最多能判断出多少层的结果，在i<=K 的时候找最小的j,使得dp[K][j]<= N
3.动态转移方程是分为两种情况
如果在当前层鸡蛋碎了，那么能得到的最大层数就是少一个鸡蛋+少一步的结果
如果在当前层鸡蛋没有碎，那么能得到的结果就是同样多鸡蛋+少一步的结果
最后加上本层
dp[k][m] = dp[k][m-1] + dp[k-1][m-1] +1;
4.一旦K个鸡蛋在m步就可以得到N层，那么跳出循环，返回m
class Solution {
public:
    int superEggDrop(int K, int N) {
        vector<vector<int>>dp(K+1,vector<int>(N+1,0));
        int m = 0;
        while(dp[K][m] < N){
            ++m;
            for(int k = 1; k <= K; ++k){
                dp[k][m] = dp[k][m-1] + dp[k-1][m-1] +1;
            }
        }
        return m;
    }
};