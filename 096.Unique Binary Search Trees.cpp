题意：
给出一个数字n，问从1-n能构造多少种二叉树
方法：DP
思路：
1.通过分析发现：
比如n=2，以1做根时，2只能在右侧，因此f(0)*f(1);以2做根时，1只能在左侧，因此f(1)*f(0);
比如n=3，以1做根时，2,3只能在右侧，因此f(0)*f(2);以2做根时，1只能在左侧,3只能在右侧，因此f(1)*f(1);以3做根时，1，2只能在左侧,因此f(2)*f(1);
那么规律是：f(n) = f(0)*f(n-1)+f(1)*f(n-2)+...+f(n-1)*f(0)
2.用一个数组进行dp,因为空树也是一种二叉搜索树，所以dp[0] = 1;以此类推，dp[i] += dp[j] * dp[i-j-1];
3.最后返回dp[n]即可
注意：数组是从0开始的，因此如果想返回n,最开始要声明n+1个0
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1,0);
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i<= n; ++i){
            for(int j = 0; j < i ;++j){
                dp[i] += dp[j] * dp[i-j-1];
            }
        }
        return dp[n];
    }
};
补充：
本题中的数列满足的规律其实叫Catalan数，卡兰塔数，常用于组合数学领域：
令h(0)=1,h(1)=1，catalan数满足递推式：
h(n)= h(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)*h(0) (n>=2)
数列为：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796......