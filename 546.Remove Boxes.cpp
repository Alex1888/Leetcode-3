题意：
移除连续重复的盒子可以等到一定的分数，找到得分最高的移除方式。
方法一：递归方法DP【思路比较难，需要反复思考】
思路：
1.本题的题意是在一个数组中消去一个或者多个数字，使得得分最高。
一般在数组内找子数组的题目首先想到dp，比如设置一个dp[i][j]数组表示在(i,j)范围内所能够得到的最高分，最后返回dp[0][n-1]的结果即可。
2.但是本题的难度在于，在移除一个或者几个数字之后，原本不连续的数字会变得连续，那么同时移除的越多，得分越高。
比如在[i,j]中间有一个数字m,使得box[i]与box[m]相等，那么最大的方法是移除dp[i+1][m-1],使dp[i]与dp[m]相邻，再进行后面的处理。
因为我们需要记录下前面的数字与后面数字的关系，因此本题需要用到三维dp[i][j][k],用来表示在dp[i][j]中的最大分数，同时box[i]左侧有k个数字与其相等，目标是dp[0][n-1][0];
3.对于dp[i][j][k]，移除boxes[i]，得到(1+k)*(1+k) + dp[i+1][j][0];
当某个位置m，有boxes[i] == boxes[m]时，考虑先移除[i+1,m-1]这部分，得到dp[i+1][m-1][0]，然后再处理剩下的部分，得到dp[m][j][k+1]
4.那么首先建立一个三维数组,vector会MLE，因此用c语言的方法进行创建。调用递归。
5.当头结点大于尾结点的时候，返回0；如果dp中的值大于0，返回dp
6.设定一个初始值是有可能的最小情况，把第一位数字单独拎出来，对后半部分调用递归。
7.从头部开始循环原数组，当遇到正在循环到的结点等于头部结点的值的时候，把中间部分单独拿出来作为一部分，头结点连上后面即k+1，作为后半部分更新。两者相加与原有值取较大。
8.最后返回dp[0][n-1][0]作为结果。
class Solution {
public:
    int removeBoxes(vector<int>& boxes) {
        int dp[100][100][100] = {0};
        return helper(boxes,0,boxes.size()-1,0,dp);
    }
    int helper(vector<int>& boxes,int i, int j, int k ,int dp[100][100][100]){
        if(i > j) return 0;
        if(dp[i][j][k] > 0) return dp[i][j][k];
        int ret = (k+1)*(k+1)+helper(boxes,i+1,j,0,dp);
        for(int m = i+1; m <= j;++m){
            if(boxes[m] == boxes[i]){
                ret = max(ret, helper(boxes,i+1,m-1,0,dp)+helper(boxes,m,j,k+1,dp));
            }
        }
        dp[i][j][k] = ret;
        return dp[i][j][k];
    }
};
方法二：迭代方法待学习