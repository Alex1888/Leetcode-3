题意：
322找最少硬币数的follow up,但是也有不同。
找出可以构成目标值的所有硬币组成，返回个数。
方法一：DP
思路：
1.某前个硬币(当前硬币为i)对于某个目标值的总数量等于没有这个硬币等于目标值时的总数量+加上这个硬币总值中减去这个硬币的值的总数量。
加号前的部分是为了求所有可能的情况的总和。
加号后的部分表示去掉这个硬币的值之后的总数量，即加上当前硬币i后等于目标值。这一步动态转移类似322.
举例：
比如有两个硬币[1,2]，钱数为5，那么钱数的5的组成方法是可以看作两部分组成，一种是由硬币1单独组成，那么仅有一种情况(1+1+1+1+1)；------对应前半部分
另一种是由1和2共同组成，说明我们的组成方法中至少需要有一个2，所以此时我们先取出一个硬币2，那么我们只要拼出钱数为3即可，这个3还是可以用硬币1和2来拼，所以就相当于求由硬币[1,2]组成的钱数为3的总方法。------对应后半部分
因此动态转移方程是：dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]];
注意需要考虑j-coins[i-1] 大于等于0，不能越界。
2.那么设置一个二维数组即可，dp[i][j]表示前i个硬币可以组成目标值j的总个数。
因为从0开始计算进行初始化，注意二维数组的长度并把每一行第一个初始化为1，即对前n个硬币来说，构成0的数量均为1.
3.最后返回即可
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<vector<int>> dp(coins.size()+1,vector<int>(amount+1,0));
        dp[0][0] = 1;
        for(int i = 1; i <= coins.size();++i){
            dp[i][0] = 1;
            for(int j = 1; j <= amount; ++j){
                if(j-coins[i-1] >= 0){
                    dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]];
                }
                else
                    dp[i][j] = dp[i-1][j];
            }
        }
        return dp[coins.size()][amount];
    }
};
方法二：一个数组进行dp
思路：
1.用一个数组记录dp,dp[i]表示组成钱数i的不同种方法
2.外层循环是先循环硬币，内层表示用一个硬币达到目标值的总个数。同样用322的方法，当前个数等于少了这个数字的个数加上当前位置的和。
3.再依次循环硬币，总数在和之上累加
4.返回dp的最后一位即可
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int>dp(amount+1,0);
        dp[0]=1;
        for(auto &c : coins){
            for(int i = c ;i <= amount;++i){
                dp[i] += dp[i - c];
            }
        }
        return dp[amount];
    }
};