题意：
给定一个string, 里面不规律的出现左括号和右括号，找到最小的值使这些括号完全匹配
思路：
1.因为要想匹配，必定先有左再有右，因此遍历这个字符串，如果是左括号，左++
2.如果是右括号，判断左括号的值，如果左大于0，那么左--，如果左==0，那么右++
3.最后输出是左+右的和
class Solution {
public:
    int minAddToMakeValid(string S) {
        if(S.empty()) return 0;
        int left = 0;
        int right = 0;
        int ret;
        for(int i = 0; i< S.size();++i){
            if(S[i] == '(' ) ++left;
            else if(S[i] == ')'){
                if(left > 0){
                    --left;
                }else{
                    ++right;
                }
            }
        }
        ret = left + right;
        return ret;
    }
};
Weekly Contest 106总结:
1.一次AC了一道easy922,一道medium921
一次通过真的比不停的提交不停的改错强百倍，一定要尽可能多的想清楚corner cases
当然看这两道题的通过率高于上周，感觉难度确实不大，不过还是要鼓励一下一次AC，排名提高到了1458名，就强在没有罚时
2.AC的题目不再赘述思路，会在总结中更新比自己更好的方法，当然我觉得我的方法还都挺直接巧妙的
3.重点说一下923题，思路会在总结里说，是一道类似3sum但是必须找出重复子数组的题
比赛中花了1个小时解题，最后关头提交有一个case不能通过，还是在别人的提醒下修改好的，因为int和long的问题
一个是最最开始有“都第三题了难度应该挺大了吧，不会不会”的心态，开始还看别人的排名。这个今后一定要杜绝，心态决定一切，要不就放弃，不放弃就立刻抓紧比赛时间思考。况且刷的题目越来越多应该开始有“别人会我也一定会”的态度了。
第二，这道题的思路是没问题的，中间的一些corner cases也想的比较清楚，但是在等差数列求和公式上耽误了很久，开始几次都没写对，不要犯弱智的低级错误，减少不必要的失误>>做错题／不会做。
