题意：374 follow up,猜价格游戏【重点复习】
思路：
1.首先该问题需要从1开始到n一个个解决，也就说说想找1-n内花费最小的，要从1-2，1-3，1-4...逐步更新
设置一个dp数组，dp[j][i]表示在j-i的范围内，所花费的最小值。数组初始化为0。
2.i用来从2循环到目标值，即右边界。j用来表示左边界。k用来表示中间值。
3.每次需要找到中间值加上左右两侧中的较大值作为当局和，在不断移动k的同时更新最小的全局和，最后dp[j][i]的值是从j到i所表示的全局最小。
4.如果j和i是连续的，那么直接返回j因为j更小，否则返回全局最小。
5.最后的结果是从dp[1][n]范围内的最小花费。
注意：
1.因为数字是从1开始的，因此在dp数组中，第0行和第0列都为空。
2.本题的解题思路是如果是一个数字，不用猜，花费为0；
如果是2个数字，那么猜较小的那个，即使不对也比猜较大的那个花费少；
如果是3个数字，那么猜的策略是猜中间的那个，因为根据高了或者低了的提示能够在下一次猜对，是在不利的形势下选择最优解，极小化极大。
拿4个数字举个例子：
我们的策略是用k来遍历所有的数字，然后再根据k分成的左右两个区间，取其中的较大cost加上k。
当k为1时，左区间为空，所以cost为0，而右区间2，3，4，根据之前的分析应该取3，所以整个cost就是1+3=4。
当k为2时，左区间为1，cost为0，右区间为3，4，cost为3，整个cost就是2+3=5。
当k为3时，左区间为1，2，cost为1，右区间为4，cost为0，整个cost就是3+1=4。
当k为4时，左区间1，2，3，cost为2，右区间为空，cost为0，整个cost就是4+2=6。
综上k的所有情况，此时我们应该取整体cost最小的，即4，为最后的答案，
class Solution {
public:
    int getMoneyAmount(int n) {
        vector<vector<int>>dp(n+1, vector<int>(n+1,0));
        for(int i = 2; i <= n ; ++i){
            for(int j = i-1; j > 0; --j){
                int global = INT_MAX;
                for(int k = j+1 ; k < i; ++k){
                    int localmin = k + max(dp[j][k-1],dp[k+1][i]);
                    global = min(global, localmin);
                }
                dp[j][i] = j+1 == i? j : global;
            }
        }
        return dp[1][n];
    }
};
补充：Minimax算法，极小化极大
1.Minimax算法又名极小化极大算法，是一种找出失败的最大可能性中的最小值的算法。
(1)Minimax是一种悲观算法，即假设对手每一步都会将我方引入从当前看理论上价值最小的格局方向，即对手具有完美决策能力。
因此我方的策略应该是选择那些对方所能达到的让我方最差情况中最好的，也就是让对方在完美决策下所对我造成的损失最小。
(2)Minimax不找理论最优解，因为理论最优解往往依赖于对手是否足够愚蠢。
Minimax中我方完全掌握主动，如果对方每一步决策都是完美的，则我方可以达到预计的最小损失格局，如果对方没有走出完美决策，则我方可能达到比预计的最悲观情况更好的结局。总之我方就是要在最坏情况中选择最好的。
2.步骤：
在保证对方也决策最优的前提下min，选择我方能选择范围内的最大值max,自底向上解决问题
(1)首先确定最大搜索深度D，D可能达到终局，也可能是一个中间格局。
(2)在最大深度为D的格局树叶子节点上，使用预定义的价值评价函数对叶子节点价值进行评价。
(3)自底向上为非叶子节点赋值。其中max节点取子节点最大值，min节点取子节点最小值。
(4)每次轮到我方时（此时必处在格局树的某个max节点），选择价值等于此max节点价值的那个子节点路径。